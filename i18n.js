export const  i18n = {
  en: {
    // Titles
    algorithmSettings: 'Algorithm Settings',
    expressionType: 'Expression Type',
    directFormula: 'Direct Formula',
    stepByStep: 'Step-by-step',
    objectiveExpression: 'Objective Expression',
    inverseOptimization: 'Inverse Optimization',
    targetValue: 'Target Value',
    tolerance: 'Tolerance',
    optimizationConfig: 'Scientific Computing & Optimal Solutions',
    variableSettings: 'Variable Settings',
    objectiveSettings: 'Objective Settings',
    constraintSettings: 'Constraint Settings',
    algorithmSettings: 'Algorithm Settings',
    modelSettings: 'Model Settings',
    basicConfig: 'Basic Configuration',
    advancedConfig: 'Advanced Configuration',
    preview: 'Preview',

    // Variable Types
    variableType: 'Variable Type',
    variableName: 'Variable Name',
    bounds: 'Bounds/Range',
    continuous: 'Continuous',
    discrete: 'Discrete',
    categorical: 'Categorical',
    ordinal: 'Ordinal',

    // Objectives
    objectiveType: 'Objective Type',
    objectiveFunction: 'Objective Function',
    singleObjective: 'Single Objective',
    multiObjective: 'Multi Objective',
    minimize: 'Minimize',
    maximize: 'Maximize',

    // Algorithms
    algorithm: 'Algorithm',
    pso: 'PSO (Particle Swarm)',
    ga: 'Genetic Algorithm',
    nsga2: 'NSGA-II (Multi-objective)',
    moead: 'MOEA/D',
    gradient: 'Gradient Descent',
    bayesian: 'Bayesian Optimization',
    scipy: 'Scipy Minimize',
    cvxpy: 'CVXPY (Convex)',

    // Models
    surrogateModel: 'Model Type',
    lightgbm: 'LightGBM',
    gaussian: 'Gaussian Process',
    randomForest: 'Random Forest',
    xgboost: 'XGBoost',
    mlp: 'Neural Network',
    noModel: 'No Model (Direct Optimization)',

    // Buttons & Actions
    addVariable: 'Add Variable',
    addObjective: 'Add Objective',
    addConstraint: 'Add Constraint',
    edit: 'Edit',
    delete: 'Delete',
    save: 'Save',
    configure: 'Configure',
    preview: 'Preview',
    applyTemplate: 'Apply Template',
    customConfig: 'Custom Configuration',
    runOptimization: 'Run Optimization',

    // Advanced
    advancedSettings: 'Advanced Settings',
    basicSettings: 'Basic Settings',

    // Messages
    selectVariableType: 'Select variable type',
    enterVariableName: 'Enter variable name',
    enterBounds: 'Enter bounds (min, max)',
    enterCategories: 'Enter categories (comma separated)',
    selectObjectiveType: 'Select objective type',
    enterObjectiveName: 'Enter objective name',

    // New fields
    targetVariable: 'Target Variable',
    selectTargetVariable: 'Select target variable',
    optimizationMode: 'Optimization Mode',
    trainingAndOptimization: 'Training + Optimization',
    inferenceOnly: 'Inference Only (Use Existing Model)',
    useExistingModel: 'Use Existing Model',
    modelPath: 'Model Path',
    dataSource: 'Data Source',
    fromPrevious: 'From Previous Operator',
    fromLocal: 'From Local File',

    // Scenario Descriptions
    financialScenario: 'Financial Portfolio: Optimize asset allocation to maximize returns and minimize risk',
    industrialScenario: 'Industrial Process: Optimize production parameters for cost, quality, and efficiency',
    inverseScenario: 'Inverse Optimization: Find input parameters to achieve target output values',
    customScenario: 'Custom configuration for specific optimization needs'
  },
  zh: {
    // 标题
    algorithmSettings: '算法设置',
    expressionType: '表达式类型',
    directFormula: '直接公式',
    stepByStep: '分步构建',
    objectiveExpression: '目标表达式',
    inverseOptimization: '逆向优化',
    targetValue: '目标值',
    tolerance: '容差',
    optimizationConfig: '科学计算最优解',
    variableSettings: '变量设置',
    objectiveSettings: '目标设置',
    constraintSettings: '约束设置',
    algorithmSettings: '算法设置',
    modelSettings: '模型设置',
    basicConfig: '基础配置',
    advancedConfig: '高级配置',
    preview: '配置预览',

    // 变量类型
    variableType: '变量类型',
    variableName: '变量名称',
    bounds: '取值范围',
    continuous: '连续变量',
    discrete: '离散变量',
    categorical: '分类变量',
    ordinal: '有序变量',

    // 目标
    objectiveType: '目标类型',
    objectiveFunction: '目标函数',
    singleObjective: '单目标',
    multiObjective: '多目标',
    minimize: '最小化',
    maximize: '最大化',

    // 算法
    algorithm: '算法',
    pso: '粒子群算法',
    ga: '遗传算法',
    nsga2: 'NSGA-II (多目标)',
    moead: 'MOEA/D',
    gradient: '梯度下降',
    bayesian: '贝叶斯优化',
    scipy: 'Scipy优化器',
    cvxpy: 'CVXPY (凸优化)',

    // 模型
    surrogateModel: '模型类型',
    lightgbm: 'LightGBM',
    gaussian: '高斯过程',
    randomForest: '随机森林',
    xgboost: 'XGBoost',
    mlp: '神经网络',
    noModel: '无模型 (直接优化)',

    // 按钮和操作
    addVariable: '添加变量',
    addObjective: '添加目标',
    addConstraint: '添加约束',
    edit: '编辑',
    delete: '删除',
    save: '保存',
    configure: '配置',
    preview: '预览',
    applyTemplate: '应用模板',
    customConfig: '自定义配置',
    runOptimization: '运行优化',

    // 高级
    advancedSettings: '高级设置',
    basicSettings: '基础设置',

    // 消息
    selectVariableType: '选择变量类型',
    enterVariableName: '输入变量名称',
    enterBounds: '输入取值范围(最小值, 最大值)',
    enterCategories: '输入分类值(逗号分隔)',
    selectObjectiveType: '选择目标类型',
    enterObjectiveName: '输入目标名称',

    // 新字段
    targetVariable: '目标变量',
    selectTargetVariable: '选择目标变量',
    optimizationMode: '优化模式',
    trainingAndOptimization: '训练+优化',
    inferenceOnly: '仅推理 (使用现有模型)',
    useExistingModel: '使用现有模型',
    modelPath: '模型路径',
    dataSource: '数据源',
    fromPrevious: '来自前序算子',
    fromLocal: '来自本地文件',

    // 场景描述
    financialScenario: '金融投资组合：优化资产配置，最大化收益并最小化风险',
    industrialScenario: '工业过程：优化生产参数，平衡成本、质量和效率',
    inverseScenario: '逆向优化：根据目标输出值寻找最优输入参数',
    customScenario: '根据特定需求进行自定义配置'
  }
};

// 算法配置
export const ALGORITHM_CONFIGS = {
  pso: {
    params: [
      { name: 'swarmsize', label: { en: 'Swarm Size', zh: '粒子数量' }, type: 'number', min: 10, max: 500, default: 50 },
      { name: 'maxiter', label: { en: 'Max Iterations', zh: '最大迭代次数' }, type: 'number', min: 10, max: 1000, default: 100 },
      { name: 'omega', label: { en: 'Inertia Weight', zh: '惯性权重' }, type: 'number', min: 0.1, max: 1, step: 0.1, default: 0.5 },
      { name: 'phip', label: { en: 'Personal Best Weight', zh: '个体最优权重' }, type: 'number', min: 0.1, max: 2, step: 0.1, default: 0.5 },
      { name: 'phig', label: { en: 'Global Best Weight', zh: '全局最优权重' }, type: 'number', min: 0.1, max: 2, step: 0.1, default: 0.5 }
    ]
  },
  ga: {
    params: [
      { name: 'population_size', label: { en: 'Population Size', zh: '种群大小' }, type: 'number', min: 10, max: 500, default: 50 },
      { name: 'generations', label: { en: 'Generations', zh: '进化代数' }, type: 'number', min: 10, max: 1000, default: 100 },
      { name: 'mutation_rate', label: { en: 'Mutation Rate', zh: '变异率' }, type: 'number', min: 0, max: 1, step: 0.01, default: 0.1 },
      { name: 'crossover_rate', label: { en: 'Crossover Rate', zh: '交叉率' }, type: 'number', min: 0, max: 1, step: 0.1, default: 0.7 }
    ]
  },
  nsga2: {
    params: [
      { name: 'population_size', label: { en: 'Population Size', zh: '种群大小' }, type: 'number', min: 10, max: 500, default: 100 },
      { name: 'generations', label: { en: 'Generations', zh: '进化代数' }, type: 'number', min: 10, max: 1000, default: 250 },
      { name: 'crossover_prob', label: { en: 'Crossover Probability', zh: '交叉概率' }, type: 'number', min: 0, max: 1, step: 0.1, default: 0.9 },
      { name: 'mutation_prob', label: { en: 'Mutation Probability', zh: '变异概率' }, type: 'number', min: 0, max: 1, step: 0.01, default: 0.1 }
    ]
  },
  bayesian: {
    params: [
      { name: 'n_initial_points', label: { en: 'Initial Points', zh: '初始点数量' }, type: 'number', min: 5, max: 50, default: 10 },
      { name: 'acq_func', label: { en: 'Acquisition Function', zh: '采集函数' }, type: 'select', options: [
        { value: 'EI', label: { en: 'Expected Improvement', zh: '期望提升' } },
        { value: 'PI', label: { en: 'Probability of Improvement', zh: '提升概率' } },
        { value: 'LCB', label: { en: 'Lower Confidence Bound', zh: '置信下界' } }
      ], default: 'EI' },
      { name: 'random_state', label: { en: 'Random State', zh: '随机种子' }, type: 'number', min: 0, max: 100, default: 42 }
    ]
  }
};

// 模型配置
export const MODEL_CONFIGS = {
  lightgbm: {
    params: [
      { name: 'num_leaves', label: { en: 'Number of Leaves', zh: '叶子数量' }, type: 'number', min: 2, max: 128, default: 31 },
      { name: 'learning_rate', label: { en: 'Learning Rate', zh: '学习率' }, type: 'number', min: 0.001, max: 1, step: 0.01, default: 0.1 },
      { name: 'n_estimators', label: { en: 'Number of Trees', zh: '树数量' }, type: 'number', min: 10, max: 1000, default: 100 },
      { name: 'max_depth', label: { en: 'Max Depth', zh: '最大深度' }, type: 'number', min: -1, max: 20, default: -1 }
    ]
  },
  gaussian: {
    params: [
      { name: 'kernel', label: { en: 'Kernel Function', zh: '核函数' }, type: 'select', options: [
        { value: 'rbf', label: { en: 'RBF', zh: 'RBF核' } },
        { value: 'matern', label: { en: 'Matern', zh: 'Matern核' } },
        { value: 'rational_quadratic', label: { en: 'Rational Quadratic', zh: '有理二次核' } }
      ], default: 'rbf' },
      { name: 'alpha', label: { en: 'Alpha', zh: 'Alpha参数' }, type: 'number', min: 1e-20, max: 1, step: 1e-10, default: 1e-10 },
      { name: 'n_restarts', label: { en: 'Number of Restarts', zh: '优化重启次数' }, type: 'number', min: 1, max: 50, default: 10 }
    ]
  },
  randomForest: {
    params: [
      { name: 'n_estimators', label: { en: 'Number of Trees', zh: '树数量' }, type: 'number', min: 10, max: 500, default: 100 },
      { name: 'max_depth', label: { en: 'Max Depth', zh: '最大深度' }, type: 'number', min: 1, max: 20, default: 10 },
      { name: 'min_samples_split', label: { en: 'Min Samples Split', zh: '最小分裂样本数' }, type: 'number', min: 2, max: 20, default: 2 }
    ]
  }
};

// 场景模板
export const SCENARIO_TEMPLATES = {
    "portfolio_optimization": {
      "title": "投资组合优化（夏普比率最大化）",
      "description": "基于夏普比率最大化的投资组合优化，考虑资产收益率的均值和协方差",
      "dataset": "portfolio_optimization.csv",
      "type": "portfolio",
      "content": {
        "optimizationMode": "direct",
        "surrogateModel": "noModel",
        "optimizer": "scipy",
        "objectiveType": "single",
        "variables": [
          {
            "name": "w0",
            "type": "continuous",
            "bounds": [
              0,
              1
            ]
          },
          {
            "name": "w1",
            "type": "continuous",
            "bounds": [
              0,
              1
            ]
          },
          {
            "name": "w2",
            "type": "continuous",
            "bounds": [
              0,
              1
            ]
          }
        ],
        "objectives": [
          {
            "name": "sharpe_ratio",
            "type": "maximize",
            "expression": "mean_return = MEAN(return_A)*w0 + MEAN(return_B)*w1 + MEAN(return_C)*w2; variance = COV(return_A, return_A)*w0*w0 + COV(return_A, return_B)*w0*w1 + COV(return_A, return_C)*w0*w2 + COV(return_B, return_A)*w1*w0 + COV(return_B, return_B)*w1*w1 + COV(return_B, return_C)*w1*w2 + COV(return_C, return_A)*w2*w0 + COV(return_C, return_B)*w2*w1 + COV(return_C, return_C)*w2*w2; sharpe_ratio = (mean_return - 0.0001) / math.sqrt(variance)"
          }
        ],
        "constraints": [
          {
            "expression": "w0 + w1 + w2 - 1",
            "type": "eq"
          }
        ],
        "optimizerParams": {
          "method": "SLSQP",
          "options": {
            "maxiter": 1000
          }
        }
      }
    },
    "engineering_design": {
      "title": "工程设计优化（成本最小化）",
      "description": "工程设计成本最小化优化，考虑材料成本和加工成本",
      "dataset": null,
      "type": "engineering",
      "content": {
        "optimizationMode": "direct",
        "surrogateModel": "noModel",
        "optimizer": "scipy",
        "objectiveType": "single",
        "variables": [
          {
            "name": "x1",
            "type": "continuous",
            "bounds": [
              0.1,
              2.0
            ]
          },
          {
            "name": "x2",
            "type": "continuous",
            "bounds": [
              0.1,
              2.0
            ]
          },
          {
            "name": "x3",
            "type": "continuous",
            "bounds": [
              1,
              10
            ]
          }
        ],
        "objectives": [
          {
            "name": "cost",
            "type": "minimize",
            "expression": "material_cost = 2*3.14159*x1*x2*x3; end_cost = 3.14159*x2**2*x1; total_cost = material_cost + end_cost"
          }
        ],
        "constraints": [
          {
            "expression": "3.14159*x2**2*x3 - 10",
            "type": "ineq"
          },
          {
            "expression": "50 - 3.14159*x2**2*x3",
            "type": "ineq"
          },
          {
            "expression": "x1 - 0.05",
            "type": "ineq"
          }
        ],
        "optimizerParams": {
          "method": "SLSQP",
          "options": {
            "maxiter": 1000
          }
        }
      }
    },
    "rosenbrock": {
      "title": "Rosenbrock函数优化（单目标）",
      "description": "经典Rosenbrock函数最小值优化测试",
      "dataset": null,
      "type": "benchmark",
      "content": {
        "optimizationMode": "direct",
        "surrogateModel": "noModel",
        "optimizer": "pso",
        "objectiveType": "single",
        "variables": [
          {
            "name": "x1",
            "type": "continuous",
            "bounds": [
              -5,
              10
            ]
          },
          {
            "name": "x2",
            "type": "continuous",
            "bounds": [
              -5,
              10
            ]
          }
        ],
        "objectives": [
          {
            "name": "rosenbrock",
            "type": "minimize",
            "expression": "term1 = (1 - x1)**2; term2 = 100*(x2 - x1**2)**2; rosenbrock = term1 + term2"
          }
        ],
        "optimizerParams": {
          "swarmsize": 50,
          "maxiter": 100
        }
      }
    },
    "unit_circle_max": {
      "title": "单位圆内最大化x+y（带约束）",
      "description": "单位圆内最大化x+y的带约束优化问题",
      "dataset": null,
      "type": "constrained",
      "content": {
        "optimizationMode": "direct",
        "surrogateModel": "noModel",
        "optimizer": "scipy",
        "objectiveType": "single",
        "variables": [
          {
            "name": "x",
            "type": "continuous",
            "bounds": [
              -1,
              1
            ]
          },
          {
            "name": "y",
            "type": "continuous",
            "bounds": [
              -1,
              1
            ]
          }
        ],
        "objectives": [
          {
            "name": "max_sum",
            "type": "maximize",
            "expression": "objective_value = x + y"
          }
        ],
        "constraints": [
          {
            "expression": "1 - x**2 - y**2",
            "type": "ineq"
          }
        ],
        "optimizerParams": {
          "method": "SLSQP",
          "options": {
            "maxiter": 200
          }
        }
      }
    },
    "surrogate_model": {
      "title": "代理模型拟合精度测试",
      "description": "LightGBM代理模型拟合精度测试",
      "dataset": "surrogate_model.csv",
      "type": "surrogate",
      "content": {
        "optimizationMode": "training",
        "surrogateModel": "lightgbm",
        "optimizer": "pso",
        "objectiveType": "single",
        "variables": [
          {
            "name": "feature1",
            "type": "continuous",
            "bounds": [
              -5,
              5
            ]
          },
          {
            "name": "feature2",
            "type": "continuous",
            "bounds": [
              -5,
              5
            ]
          },
          {
            "name": "feature3",
            "type": "continuous",
            "bounds": [
              -5,
              5
            ]
          }
        ],
        "objectives": [
          {
            "name": "minimize_target",
            "type": "minimize",
            "expression": "[target]"
          }
        ],
        "targetVariable": "target",
        "modelParams": {
          "n_estimators": 50,
          "learning_rate": 0.1,
          "verbose": -1
        },
        "optimizerParams": {
          "swarmsize": 20,
          "maxiter": 10
        }
      }
    },
    "zdt1": {
      "title": "ZDT1多目标优化",
      "description": "经典ZDT1多目标优化问题",
      "dataset": null,
      "type": "multiobjective",
      "content": {
        "optimizationMode": "direct",
        "surrogateModel": "noModel",
        "optimizer": "nsga2",
        "objectiveType": "multi",
        "variables": [
          {
            "name": "x1",
            "type": "continuous",
            "bounds": [
              0,
              1
            ]
          },
          {
            "name": "x2",
            "type": "continuous",
            "bounds": [
              0,
              1
            ]
          }
        ],
        "objectives": [
          {
            "name": "f1",
            "type": "minimize",
            "expression": "f1_value = x1"
          },
          {
            "name": "f2",
            "type": "minimize",
            "expression": "g = 1 + 9 * x2; h = 1 - sqrt(x1 / g); f2_value = g * h"
          }
        ],
        "optimizerParams": {
          "population_size": 40,
          "generations": 20
        }
      }
    },
    "factory_scheduling": {
      "title": "工厂排班优化",
      "description": "工厂人员排班成本优化",
      "dataset": null,
      "type": "scheduling",
      "content": {
        "optimizationMode": "direct",
        "surrogateModel": "noModel",
        "optimizer": "differential_evolution",
        "objectiveType": "single",
        "variables": [
          {
            "name": "staff_weekday",
            "type": "continuous",
            "bounds": [
              10,
              20
            ]
          },
          {
            "name": "staff_weekend",
            "type": "continuous",
            "bounds": [
              5,
              15
            ]
          }
        ],
        "objectives": [
          {
            "name": "min_cost",
            "type": "minimize",
            "expression": "weekday_cost = 5 * staff_weekday * 100; weekend_cost = 2 * staff_weekend * 150; total_cost = weekday_cost + weekend_cost"
          }
        ],
        "constraints": [
          {
            "expression": "staff_weekday - 8",
            "type": "ineq"
          },
          {
            "expression": "staff_weekend - 5",
            "type": "ineq"
          }
        ],
        "optimizerParams": {
          "population_size": 20,
          "generations": 30,
          "tol": 0.1
        }
      }
    },
    "production_scheduling": {
      "title": "生产调度优化",
      "description": "生产批量和速率优化",
      "dataset": null,
      "type": "production",
      "content": {
        "optimizationMode": "direct",
        "surrogateModel": "noModel",
        "optimizer": "pso",
        "objectiveType": "single",
        "variables": [
          {
            "name": "batch_size",
            "type": "continuous",
            "bounds": [
              100,
              1000
            ]
          },
          {
            "name": "production_rate",
            "type": "continuous",
            "bounds": [
              10,
              100
            ]
          },
          {
            "name": "overtime_hours",
            "type": "continuous",
            "bounds": [
              0,
              40
            ]
          }
        ],
        "objectives": [
          {
            "name": "min_total_cost",
            "type": "minimize",
            "expression": "production_cost = batch_size / production_rate * 50; overtime_cost = overtime_hours * 100; total_cost = production_cost + overtime_cost"
          }
        ],
        "constraints": [
          {
            "expression": "batch_size - 500",
            "type": "ineq"
          },
          {
            "expression": "production_rate - 20",
            "type": "ineq"
          },
          {
            "expression": "40 - overtime_hours",
            "type": "ineq"
          }
        ],
        "optimizerParams": {
          "swarmsize": 30,
          "maxiter": 100
        }
      }
    },
    "supply_chain": {
      "title": "供应链生产分配优化",
      "description": "多工厂生产分配优化",
      "dataset": null,
      "type": "supply_chain",
      "content": {
        "optimizationMode": "direct",
        "surrogateModel": "noModel",
        "optimizer": "scipy",
        "objectiveType": "single",
        "variables": [
          {
            "name": "factory1_output",
            "type": "continuous",
            "bounds": [
              0,
              2000
            ]
          },
          {
            "name": "factory2_output",
            "type": "continuous",
            "bounds": [
              0,
              1500
            ]
          },
          {
            "name": "factory3_output",
            "type": "continuous",
            "bounds": [
              0,
              2500
            ]
          }
        ],
        "objectives": [
          {
            "name": "min_total_cost",
            "type": "minimize",
            "expression": "cost1 = factory1_output * 5; cost2 = factory2_output * 6; cost3 = factory3_output * 4.5; total_cost = cost1 + cost2 + cost3"
          }
        ],
        "constraints": [
          {
            "expression": "factory1_output + factory2_output + factory3_output - 4500",
            "type": "eq"
          },
          {
            "expression": "2000 - factory1_output",
            "type": "ineq"
          },
          {
            "expression": "1500 - factory2_output",
            "type": "ineq"
          },
          {
            "expression": "2500 - factory3_output",
            "type": "ineq"
          }
        ],
        "optimizerParams": {
          "method": "SLSQP",
          "options": {
            "maxiter": 1000
          }
        }
      }
    },
    "risk_parity": {
      "title": "风险平价投资组合优化",
      "description": "风险平价投资组合优化",
      "dataset": "risk_parity.csv",
      "type": "portfolio",
      "content": {
        "optimizationMode": "direct",
        "surrogateModel": "noModel",
        "optimizer": "scipy",
        "objectiveType": "single",
        "variables": [
          {
            "name": "w0",
            "type": "continuous",
            "bounds": [
              0.01,
              0.8
            ]
          },
          {
            "name": "w1",
            "type": "continuous",
            "bounds": [
              0.01,
              0.8
            ]
          },
          {
            "name": "w2",
            "type": "continuous",
            "bounds": [
              0.01,
              0.8
            ]
          },
          {
            "name": "w3",
            "type": "continuous",
            "bounds": [
              0.01,
              0.8
            ]
          }
        ],
        "objectives": [
          {
            "name": "risk_parity",
            "type": "minimize",
            "expression": "var1 = VAR(asset1_returns); var2 = VAR(asset2_returns); var3 = VAR(asset3_returns); var4 = VAR(asset4_returns); cov12 = COV(asset1_returns, asset2_returns); cov13 = COV(asset1_returns, asset3_returns); cov14 = COV(asset1_returns, asset4_returns); cov23 = COV(asset2_returns, asset3_returns); cov24 = COV(asset2_returns, asset4_returns); cov34 = COV(asset3_returns, asset4_returns); portfolio_var = w0*w0*var1 + w1*w1*var2 + w2*w2*var3 + w3*w3*var4 + 2*w0*w1*cov12 + 2*w0*w2*cov13 + 2*w0*w3*cov14 + 2*w1*w2*cov23 + 2*w1*w3*cov24 + 2*w2*w3*cov34; rc1 = (w0*w0*var1 + w0*w1*cov12 + w0*w2*cov13 + w0*w3*cov14) / portfolio_var; rc2 = (w1*w0*cov12 + w1*w1*var2 + w1*w2*cov23 + w1*w3*cov24) / portfolio_var; rc3 = (w2*w0*cov13 + w2*w1*cov23 + w2*w2*var3 + w2*w3*cov34) / portfolio_var; rc4 = (w3*w0*cov14 + w3*w1*cov24 + w3*w2*cov34 + w3*w3*var4) / portfolio_var; risk_parity = (rc1 - 0.25)**2 + (rc2 - 0.25)**2 + (rc3 - 0.25)**2 + (rc4 - 0.25)**2"
          }
        ],
        "constraints": [
          {
            "expression": "w0 + w1 + w2 + w3 - 1",
            "type": "eq"
          }
        ],
        "optimizerParams": {
          "method": "SLSQP",
          "options": {
            "maxiter": 500
          }
        }
      }
    },
    "mean_variance": {
      "title": "均值-方差投资组合优化",
      "description": "经典均值-方差投资组合优化",
      "dataset": "mean_variance.csv",
      "type": "portfolio",
      "content": {
        "optimizationMode": "direct",
        "surrogateModel": "noModel",
        "optimizer": "scipy",
        "objectiveType": "single",
        "variables": [
          {
            "name": "w_stock",
            "type": "continuous",
            "bounds": [
              0.0,
              0.8
            ]
          },
          {
            "name": "w_bond",
            "type": "continuous",
            "bounds": [
              0.0,
              0.6
            ]
          },
          {
            "name": "w_reit",
            "type": "continuous",
            "bounds": [
              0.0,
              0.4
            ]
          }
        ],
        "objectives": [
          {
            "name": "efficient_frontier",
            "type": "minimize",
            "expression": "mean_return = MEAN(stock_returns)*w_stock + MEAN(bond_returns)*w_bond + MEAN(reit_returns)*w_reit; var_stock = VAR(stock_returns); var_bond = VAR(bond_returns); var_reit = VAR(reit_returns); cov_sb = COV(stock_returns, bond_returns); cov_sr = COV(stock_returns, reit_returns); cov_br = COV(bond_returns, reit_returns); portfolio_variance = w_stock*w_stock*var_stock + w_bond*w_bond*var_bond + w_reit*w_reit*var_reit + 2*w_stock*w_bond*cov_sb + 2*w_stock*w_reit*cov_sr + 2*w_bond*w_reit*cov_br; risk_aversion = 2; utility = portfolio_variance * risk_aversion - mean_return"
          }
        ],
        "constraints": [
          {
            "expression": "w_stock + w_bond + w_reit - 1",
            "type": "eq"
          },
          {
            "expression": "MEAN(stock_returns)*w_stock + MEAN(bond_returns)*w_bond + MEAN(reit_returns)*w_reit - 0.0010",
            "type": "ineq"
          }
        ],
        "optimizerParams": {
          "method": "SLSQP",
          "options": {
            "maxiter": 1000
          }
        }
      }
    },
    "target_volatility": {
      "title": "目标波动率投资组合优化",
      "description": "目标波动率投资组合优化",
      "dataset": "target_volatility.csv",
      "type": "portfolio",
      "content": {
        "optimizationMode": "direct",
        "surrogateModel": "noModel",
        "optimizer": "scipy",
        "objectiveType": "single",
        "variables": [
          {
            "name": "w_growth",
            "type": "continuous",
            "bounds": [
              0.0,
              0.7
            ]
          },
          {
            "name": "w_value",
            "type": "continuous",
            "bounds": [
              0.0,
              0.7
            ]
          },
          {
            "name": "w_defensive",
            "type": "continuous",
            "bounds": [
              0.0,
              0.6
            ]
          }
        ],
        "objectives": [
          {
            "name": "max_return_vol_target",
            "type": "maximize",
            "expression": "portfolio_return = MEAN(growth_asset)*w_growth + MEAN(value_asset)*w_value + MEAN(defensive_asset)*w_defensive"
          }
        ],
        "constraints": [
          {
            "expression": "w_growth + w_value + w_defensive - 1",
            "type": "eq"
          },
          {
            "expression": "sqrt(VAR(growth_asset)*w_growth*w_growth + VAR(value_asset)*w_value*w_value + VAR(defensive_asset)*w_defensive*w_defensive + 2*COV(growth_asset, value_asset)*w_growth*w_value + 2*COV(growth_asset, defensive_asset)*w_growth*w_defensive + 2*COV(value_asset, defensive_asset)*w_value*w_defensive) - 0.015",
            "type": "eq"
          }
        ],
        "optimizerParams": {
          "method": "SLSQP",
          "options": {
            "maxiter": 1000
          }
        }
      }
    },
    "optimizer_comparison": {
      "title": "优化算法性能对比",
      "description": "不同优化算法性能对比测试",
      "dataset": null,
      "type": "comparison",
      "content": {
        "optimizationMode": "direct",
        "surrogateModel": "noModel",
        "optimizer": "pso",
        "objectiveType": "single",
        "variables": [
          {
            "name": "x1",
            "type": "continuous",
            "bounds": [
              -5,
              5
            ]
          },
          {
            "name": "x2",
            "type": "continuous",
            "bounds": [
              -5,
              5
            ]
          },
          {
            "name": "x3",
            "type": "continuous",
            "bounds": [
              -5,
              5
            ]
          }
        ],
        "objectives": [
          {
            "name": "sphere",
            "type": "minimize",
            "expression": "x1_sq = x1**2; x2_sq = x2**2; x3_sq = x3**2; sphere = x1_sq + x2_sq + x3_sq"
          }
        ],
        "optimizerParams": {
          "swarmsize": 30,
          "maxiter": 50
        }
      }
    },
    "historical_production": {
      "title": "历史生产数据排程优化",
      "description": "基于历史数据的生产排程优化",
      "dataset": "historical_production.csv",
      "type": "production",
      "content": {
        "optimizationMode": "direct",
        "surrogateModel": "noModel",
        "optimizer": "pso",
        "objectiveType": "single",
        "variables": [
          {
            "name": "daily_capacity",
            "type": "continuous",
            "bounds": [
              60,
              120
            ]
          },
          {
            "name": "safety_stock",
            "type": "continuous",
            "bounds": [
              5,
              30
            ]
          },
          {
            "name": "maintenance_frequency",
            "type": "continuous",
            "bounds": [
              2,
              10
            ]
          },
          {
            "name": "worker_shifts",
            "type": "continuous",
            "bounds": [
              1.5,
              3
            ]
          }
        ],
        "objectives": [
          {
            "name": "max_efficiency",
            "type": "maximize",
            "expression": "predicted_breakdowns = MEAN(machine_breakdowns) / maintenance_frequency; predicted_absenteeism = MEAN(worker_absenteeism) / worker_shifts; predicted_quality = MEAN(production_quality) * (1 - 0.1 * predicted_breakdowns); predicted_overtime = MEAN(overtime_hours) * (daily_capacity / MEAN(order_volume)); efficiency_score = predicted_quality / (predicted_overtime + 1)"
          }
        ],
        "constraints": [
          {
            "expression": "daily_capacity - MEAN(order_volume) - safety_stock",
            "type": "ineq"
          },
          {
            "expression": "1800 - MEAN(energy_consumption) * daily_capacity / MEAN(order_volume)",
            "type": "ineq"
          }
        ],
        "optimizerParams": {
          "swarmsize": 30,
          "maxiter": 200
        }
      }
    },
    "inverse_continuous": {
      "title": "逆向优化-工艺参数（连续变量）",
      "description": "逆向优化-工艺参数反推",
      "dataset": "inverse_continuous.csv",
      "type": "inverse",
      "content": {
        "optimizationMode": "inverse",
        "surrogateModel": "noModel",
        "optimizer": "differential_evolution",
        "objectiveType": "single",
        "variables": [
          {
            "name": "temperature",
            "type": "continuous",
            "bounds": [
              150,
              300
            ]
          },
          {
            "name": "pressure",
            "type": "continuous",
            "bounds": [
              50,
              150
            ]
          },
          {
            "name": "speed",
            "type": "continuous",
            "bounds": [
              100,
              500
            ]
          },
          {
            "name": "cooling_time",
            "type": "continuous",
            "bounds": [
              10,
              60
            ]
          }
        ],
        "objectives": [
          {
            "name": "quality_deviation",
            "type": "minimize",
            "expression": "abs((0.6 *exp(-((temperature-220)/50)**2) + 0.3 * exp(-((pressure-100)/30)**2) + 0.1 * (1 - abs(speed-300)/200) + 0.2 * tanh(cooling_time/30) - 0.1 * ((temperature-220)*(pressure-100))/5000) - 0.95)"
          }
        ],
        "constraints": [
          {
            "expression": "temperature + pressure - 350",
            "type": "ineq"
          }
        ],
        "inverseTarget": 0.95,
        "inverseTolerance": 0.02,
        "optimizerParams": {
          "population_size": 50,
          "generations": 100
        }
      }
    },
    "inverse_discrete": {
      "title": "逆向优化-供应链设计（离散变量）",
      "description": "逆向优化-供应链网络设计",
      "dataset": "inverse_discrete.csv",
      "type": "inverse",
      "content": {
        "optimizationMode": "inverse",
        "surrogateModel": "noModel",
        "optimizer": "ga",
        "objectiveType": "single",
        "variables": [
          {
            "name": "warehouse_A",
            "type": "integer",
            "bounds": [
              0,
              2
            ]
          },
          {
            "name": "warehouse_B",
            "type": "integer",
            "bounds": [
              0,
              2
            ]
          },
          {
            "name": "warehouse_C",
            "type": "integer",
            "bounds": [
              0,
              3
            ]
          },
          {
            "name": "transport_mode",
            "type": "integer",
            "bounds": [
              0,
              2
            ]
          },
          {
            "name": "inventory_strategy",
            "type": "integer",
            "bounds": [
              0,
              2
            ]
          }
        ],
        "objectives": [
          {
            "name": "cost_service_tradeoff",
            "type": "minimize",
            "expression": "(50000 * (warehouse_A == 0) + 80000 * (warehouse_A == 1) + 120000 * (warehouse_A == 2) + 40000 * (warehouse_B == 0) + 70000 * (warehouse_B == 1) + 100000 * (warehouse_B == 2) + 30000 * (warehouse_C == 0) + 50000 * (warehouse_C == 1) + 80000 * (warehouse_C == 2) + 0 * (warehouse_C == 3) + 1000000 * abs((0.2 * (warehouse_A == 0) + 0.3 * (warehouse_A == 1) + 0.4 * (warehouse_A == 2) + 0.15 * (warehouse_B == 0) + 0.25 * (warehouse_B == 1) + 0.35 * (warehouse_B == 2) + 0.1 * (warehouse_C == 0) + 0.2 * (warehouse_C == 1) + 0.3 * (warehouse_C == 2) + 0 * (warehouse_C == 3) + 0.1 * (transport_mode == 0) + 0.05 * (transport_mode == 1) + 0.08 * (transport_mode == 2) + 0.05 * (inventory_strategy == 0) + 0.1 * (inventory_strategy == 1) + 0.15 * (inventory_strategy == 2)) - 0.95))"
          }
        ],
        "inverseTarget": 0.95,
        "inverseTolerance": 0.03,
        "optimizerParams": {
          "population_size": 30,
          "generations": 50,
          "crossover_prob": 0.8,
          "mutation_prob": 0.1
        }
      }
    },
    "ant_colony": {
      "title": "蚁群算法-物流路径规划",
      "description": "蚁群算法-物流路径规划",
      "dataset": "ant_colony.csv",
      "type": "metaheuristic",
      "content": {
        "optimizationMode": "direct",
        "surrogateModel": "noModel",
        "optimizer": "ant_colony",
        "objectiveType": "single",
        "variables": [
          {
            "name": "visit_order_0",
            "type": "integer",
            "bounds": [
              0,
              7
            ]
          },
          {
            "name": "visit_order_1",
            "type": "integer",
            "bounds": [
              0,
              7
            ]
          },
          {
            "name": "visit_order_2",
            "type": "integer",
            "bounds": [
              0,
              7
            ]
          },
          {
            "name": "visit_order_3",
            "type": "integer",
            "bounds": [
              0,
              7
            ]
          },
          {
            "name": "visit_order_4",
            "type": "integer",
            "bounds": [
              0,
              7
            ]
          },
          {
            "name": "visit_order_5",
            "type": "integer",
            "bounds": [
              0,
              7
            ]
          },
          {
            "name": "visit_order_6",
            "type": "integer",
            "bounds": [
              0,
              7
            ]
          },
          {
            "name": "visit_order_7",
            "type": "integer",
            "bounds": [
              0,
              7
            ]
          }
        ],
        "objectives": [
          {
            "name": "total_route_cost",
            "type": "minimize",
            "expression": "total_distance = 0; for i in range(7): from_loc = visit_order_i; to_loc = visit_order_{i+1}; total_distance += distance_matrix[from_loc, to_loc]; total_distance += distance_matrix[visit_order_7, visit_order_0]; avg_traffic = MEAN(traffic_congestion); time_penalty = total_distance * avg_traffic * 0.1; avg_fuel_cost = MEAN(fuel_cost); fuel_cost_total = total_distance * avg_fuel_cost * 0.01; total_route_cost = total_distance + time_penalty + fuel_cost_total"
          }
        ],
        "constraints": [
          {
            "expression": "sum([visit_order_0, visit_order_1, visit_order_2, visit_order_3, visit_order_4, visit_order_5, visit_order_6, visit_order_7]) - 28",
            "type": "eq"
          }
        ],
        "optimizerParams": {
          "ants_count": 20,
          "iterations": 50,
          "alpha": 1.0,
          "beta": 2.0,
          "evaporation": 0.5
        }
      }
    },
    "nsga2_production": {
      "title": "NSGA2-生产质量效率多目标优化",
      "description": "NSGA2-生产质量效率多目标优化",
      "dataset": "nsga2_production.csv",
      "type": "multiobjective",
      "content": {
        "optimizationMode": "direct",
        "surrogateModel": "noModel",
        "optimizer": "nsga2",
        "objectiveType": "multi",
        "variables": [
          {
            "name": "machine_speed",
            "type": "continuous",
            "bounds": [
              80,
              120
            ]
          },
          {
            "name": "temperature",
            "type": "continuous",
            "bounds": [
              180,
              220
            ]
          },
          {
            "name": "pressure",
            "type": "continuous",
            "bounds": [
              60,
              100
            ]
          },
          {
            "name": "operator_skill",
            "type": "integer",
            "bounds": [
              1,
              3
            ]
          }
        ],
        "objectives": [
          {
            "name": "maximize_quality",
            "type": "maximize",
            "expression": "(0.6 * (1 - abs(temperature - 200) / 40) + 0.3 * (1 - abs(pressure - 80) / 40) + 0.1 * (machine_speed - 80) / 40 + 0.2 * (operator_skill - 1) / 2)"
          },
          {
            "name": "maximize_efficiency",
            "type": "maximize",
            "expression": "(0.7 * machine_speed / 120 + 0.2 * (1 - abs(temperature - 190) / 30) + 0.1 * (pressure - 60) / 40)"
          },
          {
            "name": "minimize_energy",
            "type": "minimize",
            "expression": "(machine_speed * 0.8 + temperature * 0.5 + pressure * 0.3 - 10 * (0.6 * (1 - abs(temperature - 200) / 40) + 0.3 * (1 - abs(pressure - 80) / 40) + 0.1 * (machine_speed - 80) / 40 + 0.2 * (operator_skill - 1) / 2))"
          }
        ],
        "optimizerParams": {
          "population_size": 100,
          "generations": 200
        }
      }
    },
    "nsga2_maintenance": {
      "title": "NSGA2-设备维护多目标优化",
      "description": "NSGA2-设备维护多目标优化",
      "dataset": "nsga2_maintenance.csv",
      "type": "multiobjective",
      "content": {
        "optimizationMode": "direct",
        "surrogateModel": "noModel",
        "optimizer": "nsga2",
        "objectiveType": "multi",
        "variables": [
          {
            "name": "preventive_interval",
            "type": "integer",
            "bounds": [
              100,
              500
            ]
          },
          {
            "name": "spare_part_level",
            "type": "continuous",
            "bounds": [
              0.1,
              0.8
            ]
          },
          {
            "name": "maintenance_team",
            "type": "integer",
            "bounds": [
              2,
              10
            ]
          },
          {
            "name": "inspection_frequency",
            "type": "integer",
            "bounds": [
              50,
              200
            ]
          }
        ],
        "objectives": [
          {
            "name": "minimize_total_cost",
            "type": "minimize",
            "expression": "(160 / preventive_interval * 800 + 0.3 * (1 - preventive_interval / 500) * 5000 + spare_part_level * 100000 + maintenance_team * 75000)"
          },
          {
            "name": "maximize_availability",
            "type": "maximize",
            "expression": "((0.9 - 0.3 * (preventive_interval - 100) / 400) * (0.8 - 0.2 * (inspection_frequency - 50) / 150) * (0.7 + 0.2 * (maintenance_team - 2) / 8))"
          },
          {
            "name": "minimize_energy_waste",
            "type": "minimize",
            "expression": "((preventive_interval - 200) ** 2 / 100000 + maintenance_team * 2 * 50)"
          }
        ],
        "optimizerParams": {
          "population_size": 80,
          "generations": 150
        }
      }
    },
    "nsga2_inventory": {
      "title": "NSGA2-供应链库存多目标优化",
      "description": "NSGA2-供应链库存多目标优化",
      "dataset": "nsga2_inventory.csv",
      "type": "multiobjective",
      "content": {
        "optimizationMode": "direct",
        "surrogateModel": "noModel",
        "optimizer": "nsga2",
        "objectiveType": "multi",
        "variables": [
          {
            "name": "safety_stock_level",
            "type": "continuous",
            "bounds": [
              0.1,
              0.4
            ]
          },
          {
            "name": "reorder_point",
            "type": "continuous",
            "bounds": [
              0.5,
              2.0
            ]
          },
          {
            "name": "order_quantity",
            "type": "continuous",
            "bounds": [
              0.8,
              3.0
            ]
          },
          {
            "name": "review_period",
            "type": "integer",
            "bounds": [
              1,
              14
            ]
          }
        ],
        "objectives": [
          {
            "name": "minimize_total_cost",
            "type": "minimize",
            "expression": "(safety_stock_level * 100 * 10 * 30 + 100 * 100 / (order_quantity * 100) + 0.5 * (1 - safety_stock_level) * 1000)"
          },
          {
            "name": "maximize_service_level",
            "type": "maximize",
            "expression": "((1 - 0.3 * (reorder_point - 1.0)) * (0.8 + 0.4 * safety_stock_level) * (1 - 0.1 * (review_period - 1) / 13))"
          },
          {
            "name": "minimize_bullwhip_effect",
            "type": "minimize",
            "expression": "(abs(order_quantity - 1.5) * 0.3 + abs(review_period - 7) * 0.02)"
          }
        ],
        "optimizerParams": {
          "population_size": 60,
          "generations": 120
        }
      }
    },
    "nsga2_quality": {
      "title": "NSGA2-质量工艺参数多目标优化",
      "description": "NSGA2-质量工艺参数多目标优化",
      "dataset": "nsga2_quality.csv",
      "type": "multiobjective",
      "content": {
        "optimizationMode": "direct",
        "surrogateModel": "noModel",
        "optimizer": "nsga2",
        "objectiveType": "multi",
        "variables": [
          {
            "name": "process_temp",
            "type": "continuous",
            "bounds": [
              150,
              250
            ]
          },
          {
            "name": "process_pressure",
            "type": "continuous",
            "bounds": [
              50,
              150
            ]
          },
          {
            "name": "process_time",
            "type": "continuous",
            "bounds": [
              30,
              120
            ]
          },
          {
            "name": "material_viscosity",
            "type": "continuous",
            "bounds": [
              1000,
              5000
            ]
          }
        ],
        "objectives": [
          {
            "name": "minimize_defect_rate",
            "type": "minimize",
            "expression": "(0.4 * (abs(process_temp - 200) / 50) + 0.3 * (abs(process_pressure - 100) / 50) + 0.2 * (abs(process_time - 75) / 45) + 0.1 * (abs(material_viscosity - 3000) / 2000))"
          },
          {
            "name": "maximize_throughput",
            "type": "maximize",
            "expression": "((0.5 * (1 / process_time) * 120 + 0.3 * (process_pressure / 150) + 0.2 * (process_temp / 250)) / 3.0)"
          },
          {
            "name": "minimize_energy",
            "type": "minimize",
            "expression": "((process_temp * 2.0 + process_pressure * 1.5 + process_time * 0.8 + material_viscosity * 0.001) / 1000)"
          }
        ],
        "optimizerParams": {
          "population_size": 50,
          "generations": 100
        }
      }
    },
    "nsga2_simple": {
      "title": "NSGA2-ZDT1简单多目标优化",
      "description": "NSGA2-ZDT1简单多目标测试",
      "dataset": null,
      "type": "multiobjective",
      "content": {
        "optimizationMode": "direct",
        "surrogateModel": "noModel",
        "optimizer": "nsga2",
        "objectiveType": "multi",
        "variables": [
          {
            "name": "x1",
            "type": "continuous",
            "bounds": [
              0,
              1
            ]
          },
          {
            "name": "x2",
            "type": "continuous",
            "bounds": [
              0,
              1
            ]
          }
        ],
        "objectives": [
          {
            "name": "f1",
            "type": "minimize",
            "expression": "x1"
          },
          {
            "name": "f2",
            "type": "minimize",
            "expression": "(1 + 9 * x2) * (1 - sqrt(x1 / (1 + 9 * x2)))"
          }
        ],
        "optimizerParams": {
          "population_size": 40,
          "generations": 20
        }
      }
    }
  }